# Tencent Experience

- 2020/03/31

## 题目描述

&#160; &#160; &#160; &#160; 给定一个结构体`Item`，其定义如下:

```cpp
struct Item {
    int key;
    int value;
};
```

&#160; &#160; &#160; &#160; 请实现以下功能：

- 1. 对于给定的一组Item，实现将key为零的Item移动到数组的后端，且保证所有key非零的Item的相对位置保持不变；

- 2. 对于给定的一组Item，实现将组内的Item按照value降序排列。

### 样例

#### 输入

```cpp
arr[MAX_SIZE] = {(1, 2), (3, 5), (6, 1), (0, 0), (7, 4), (0, 0), (0, 0), (4, 3), (0, 0)}
// 这里的输入只是伪代码，实际执行请自己进行控制
```

#### 输出

&#160; &#160; &#160; &#160; 针对第一个功能：

```cpp
{(1, 2), (3, 5), (6, 1), (7, 4), (4, 3), (0, 0), (0, 0), (0, 0), (0, 0)}
```

&#160; &#160; &#160; &#160; 针对第二个功能：

```cpp
{(3, 5), (7, 4), (4, 3), (1, 2), (6, 1), (0, 0), (0, 0), (0, 0), (0, 0)}
```

## 题目描述

&#160; &#160; &#160; &#160; 对于给定的一组数，如果相邻的三个数之间是按照相邻升序/相邻降序，那么输出这三个数的两端的数字；否则，输出该数字。

### 样例

#### 输入

```cpp
arr = {1, 2, 3, 5, 7, -2, -1, 0}
```

#### 输出

```cpp
{1, 3, 5, 7, -2, 0}
```

&#160; &#160; &#160; &#160; 说明: 相邻升序/相邻降序是指这三个数字是整数排序相邻的，且这三个数要么升序排列、要么降序排列。

&#160; &#160; &#160; &#160; 这里的`1, 2, 3`是相邻升序的，所以输出`1, 3`；而`5`则不是相邻的，所以直接输出即可。

## 评价

&#160; &#160; &#160; &#160; 这两道题真的是很简单的题，可能重点在于考察逻辑/代码能力。在面试时，我基本就是读完题就知道该怎么做了：

&#160; &#160; &#160; &#160; 第一题的两个子问题，分别使用双指针(快慢指针)、Lambda表达式即可，问题不大。重点在于细节，比如第一次编译出错，在struct域后忘了加';`...

&#160; &#160; &#160; &#160; 第二题，使用一个长度为3的滑动窗口，即可直接求解。可能题目的描述过于简陋，且对于样例来说较为晦涩... 但明白逻辑就足够了。需要说明的是，为什么不使用窗口中间的元素进行判断？因为当一个窗口满足相邻升序/相邻降序时，这个窗口直接就跳过去了，所以可以直接使用窗口的第一个元素进行判断，这样就可以直接求解。

